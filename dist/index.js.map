{"version":3,"sources":["../src/index.ts"],"names":["ExtendedSet","_ExtendedSet","anArray","callbackFilterFn","filteredSet","item","args","callbackReduce","initialValue","isInvalidInitialValue","first","restSet","internalReduce","set","result","callback","other","others","unionSets","intersectionSet","differenceSet"],"mappings":"AAYA,IAAqBA,EAArB,MAAqBC,UAA0B,GAAU,CACvD,OAAO,GAASC,EAAiB,CAC/B,OAAO,IAAID,EAAkBC,CAAO,CACtC,CAEO,OAAOC,EAAwC,CACpD,IAAMC,EAAc,IAAIH,EACxB,QAAWI,KAAQ,KACZF,EAAiBE,CAAI,GAC1BD,EAAY,IAAIC,CAAI,EAEtB,OAAOD,CACT,CAOO,UAAUE,EAAa,CAC5B,GAAM,CAACC,EAAgBC,CAAY,EAAIF,EACvC,GAAIG,EAAsB,EAAG,CAC3B,GAAM,CAACC,EAAO,GAAGC,CAAO,EAAI,KAC5B,OAAOC,EAAeD,EAASD,CAAK,CACtC,CAEA,OAAOE,EAAe,KAAMJ,CAAY,EACxC,SAASC,GAAiC,CACxC,OAAqCD,GAAiB,IACxD,CACA,SAASI,EAAeC,EAAyBL,EAAmB,CAClE,IAAIM,EAASN,EACb,QAAWH,KAAQQ,EACjBC,EAASP,EAAeO,EAAQT,CAAI,EAEtC,OAAOS,CACT,CACF,CAEO,IACLC,EACsB,CACtB,IAAMD,EAAS,IAAIb,EACnB,QAAWI,KAAQ,KACjBS,EAAO,IAAIC,EAASV,CAAI,CAAC,EAE3B,OAAOS,CACT,CAEO,KAAKC,EAA2C,CACrD,QAAWV,KAAQ,KACjB,GAAIU,EAASV,CAAI,EAAG,OAAOA,EAE7B,OAAO,IACT,CAEO,MAAMU,EAAwC,CACnD,QAAWV,KAAQ,KACjB,GAAI,CAACU,EAASV,CAAI,EAAG,MAAO,GAE9B,MAAO,EACT,CAEO,KAAKU,EAAuC,CACjD,QAAWV,KAAQ,KACjB,GAAIU,EAASV,CAAI,EAAG,MAAO,GAE7B,MAAO,EACT,CAEO,aAAqCW,EAAgC,CAC1E,QAAWX,KAAQW,EACjB,GAAI,CAAC,KAAK,IAAIX,CAAI,EAAG,MAAO,GAE9B,MAAO,EACT,CAEO,WAAWW,EAA2B,CAC3C,QAAWX,KAAQ,KACjB,GAAI,CAACW,EAAM,IAAIX,CAAI,EAAG,MAAO,GAE/B,MAAO,EACT,CAEO,SACFY,EACgB,CACnB,OAAO,KAAK,iBAAiB,CAAC,KAAM,GAAGA,CAAM,CAAC,CAChD,CAEQ,iBAAuCA,EAAwB,CACrE,IAAMC,EAAY,IAAIjB,EACtB,QAAWY,KAAOI,EAChB,QAAWZ,KAAQQ,EAAKK,EAAU,IAAIb,CAAI,EAE5C,OAAOa,CACT,CAEO,aACLF,EACmB,CACnB,IAAMG,EAAkB,IAAIlB,EAC5B,QAAWI,KAAQW,EACb,KAAK,IAAIX,CAAI,GAAGc,EAAgB,IAAId,CAAI,EAE9C,OAAOc,CACT,CAEO,WACLH,EACmB,CACnB,IAAMI,EAAgB,IAAInB,EAC1B,QAAWI,KAAQW,EACZ,KAAK,IAAIX,CAAI,GAAGe,EAAc,IAAIf,CAAI,EAE7C,OAAOe,CACT,CAEO,SAAkB,CACvB,MAAO,CAAC,GAAG,IAAI,CACjB,CAEA,IAAK,OAAO,WAAW,GAAI,CACzB,MAAO,aACT,CAEO,UAAW,CAChB,MAAO,CAAC,GAAG,IAAI,EAAE,KAAK,CACxB,CACF","sourcesContent":["type CallbackFilter<Type> = (args: Type) => boolean\n\ntype CallbackReduce<InitialType, Type> = (\n  previousValue: InitialType,\n  currentValue: Type,\n) => InitialType\n\ntype CallbackFind<Type> = (item: Type) => boolean\ntype CallbackEvery<Type> = CallbackFind<Type>\ntype CallbackSome<Type> = CallbackFind<Type>\ntype CallbackMap<TInput, TOutput> = (arg: TInput) => TOutput\n\nexport default class ExtendedSet<Type> extends Set<Type> {\n  static of<Type>(anArray: Type[]) {\n    return new ExtendedSet<Type>(anArray)\n  }\n\n  public filter(callbackFilterFn: CallbackFilter<Type>) {\n    const filteredSet = new ExtendedSet<Type>()\n    for (const item of this) {\n      if (!callbackFilterFn(item)) continue\n      filteredSet.add(item)\n    }\n    return filteredSet\n  }\n\n  public reduce(callbackReduce: CallbackReduce<Type, Type>): Type\n  public reduce<InitialType>(\n    callbackReduce: CallbackReduce<InitialType, Type>,\n    initialValue: InitialType,\n  ): InitialType\n  public reduce(...args: any[]) {\n    const [callbackReduce, initialValue] = args\n    if (isInvalidInitialValue()) {\n      const [first, ...restSet] = this\n      return internalReduce(restSet, first)\n    }\n\n    return internalReduce(this, initialValue)\n    function isInvalidInitialValue(): boolean {\n      return initialValue === undefined || initialValue === null\n    }\n    function internalReduce(set: Set<Type> | Type[], initialValue: any) {\n      let result = initialValue\n      for (const item of set) {\n        result = callbackReduce(result, item)\n      }\n      return result\n    }\n  }\n\n  public map<TOutput>(\n    callback: CallbackMap<Type, TOutput>,\n  ): ExtendedSet<TOutput> {\n    const result = new ExtendedSet<TOutput>()\n    for (const item of this) {\n      result.add(callback(item))\n    }\n    return result\n  }\n\n  public find(callback: CallbackFind<Type>): Type | null {\n    for (const item of this) {\n      if (callback(item)) return item\n    }\n    return null\n  }\n\n  public every(callback: CallbackEvery<Type>): boolean {\n    for (const item of this) {\n      if (!callback(item)) return false\n    }\n    return true\n  }\n\n  public some(callback: CallbackSome<Type>): boolean {\n    for (const item of this) {\n      if (callback(item)) return true\n    }\n    return false\n  }\n\n  public isSuperSetOf<TSuperSet extends Type>(other: Set<TSuperSet>): boolean {\n    for (const item of other) {\n      if (!this.has(item)) return false\n    }\n    return true\n  }\n\n  public isSubSetOf(other: Set<Type>): boolean {\n    for (const item of this) {\n      if (!other.has(item)) return false\n    }\n    return true\n  }\n\n  public union<TSubSet extends Type>(\n    ...others: Set<TSubSet>[]\n  ): ExtendedSet<Type> {\n    return this.performUnionSets([this, ...others])\n  }\n\n  private performUnionSets<TSubSet extends Type>(others: Set<TSubSet>[]) {\n    const unionSets = new ExtendedSet<Type>()\n    for (const set of others) {\n      for (const item of set) unionSets.add(item)\n    }\n    return unionSets\n  }\n\n  public intersection<TIntersectionSet extends Type>(\n    other: Set<TIntersectionSet>,\n  ): ExtendedSet<Type> {\n    const intersectionSet = new ExtendedSet<Type>()\n    for (const item of other) {\n      if (this.has(item)) intersectionSet.add(item)\n    }\n    return intersectionSet\n  }\n\n  public difference<TDifferenceSet extends Type>(\n    other: Set<TDifferenceSet>,\n  ): ExtendedSet<Type> {\n    const differenceSet = new ExtendedSet<Type>()\n    for (const item of other) {\n      if (!this.has(item)) differenceSet.add(item)\n    }\n    return differenceSet\n  }\n\n  public toArray(): Type[] {\n    return [...this]\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ExtendedSet'\n  }\n\n  public toString() {\n    return [...this].join()\n  }\n}\n"]}